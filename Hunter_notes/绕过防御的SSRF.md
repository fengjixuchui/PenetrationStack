# 漏洞散记
##  Slack的SSRF Bypass
> SSRF的绕过在一定程度上都在先前被很完善的提过了，但是这次单独还要再说一遍是因为技术的发展从而产生的一种绕过方式，并且非常的有趣。

> 漏洞价值:500$

>源地址:[#386292](https://hackerone.com/reports/386292)

## 漏洞过程

这个漏洞发生在一个**app**请求页上，按照提示的内容来看
```
Your app can subscribe to be notified of events in Slack (for example, when a user adds a reaction or creates a file) at a URL you choose.
```
应该是一个订阅模块，会向一个指定的`url`发送一个`post`请求，大概是当作订阅信息吧。

## Protection

这儿的保护技术我并没有完全理解，但是根据`URL`填写为`https://www.google.com`后返回的信息来判断
```
Your request URL gave us a 500 error. Update your URL to receive a new request and challenge value.
```
也就是说我们填写的`URL`必须返回一个合适的状态码才行

## 思路
首先目前的正则防御SSRF大多会检测输入中是否存在`localhost`，`127.0.0.1`这样的东西，甚至包含了`协议`，`十六进制/八进制/十进制`的表示。但是针对`V6`，实际上非常多的安全产品都有意的避开了，因此这儿是一个非常明显的短板。

这儿我唯一的疑问就是如果直接填入的是`http://[::]:22//`会怎样呢？因为没有实际环境所以无法验证，但是一定猜测上可能是有正则拦截，认为这不是一个合法的`URL`导致利用失败。那么一个`Location`的跳转思路就及其漂亮。
这样的利用方式可以保证下面两点:
1. 合理的URL形态
2. 状态码并非为`500/403`这样的异常


## 小知识

IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。IPv6有3种表示方法。
1. 冒分十六进制表示法
　　格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：
　　ABCD:EF01:2345:6789:ABCD:EF01:2345:6789
　　这种表示法中，每个X的前导0是可以省略的，例如：
　　2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A
2. 0位压缩表示法
　　在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中”::”只能出现一次，例如：
　　FF01:0:0:0:0:0:0:1101 → FF01::1101
　　0:0:0:0:0:0:0:1 → ::1
　　0:0:0:0:0:0:0:0 → ::
3. 内嵌IPv4地址表示法
　　为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用 [9]  。
